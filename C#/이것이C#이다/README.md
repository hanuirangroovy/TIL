# 이것이 C#이다

## 목차

1. [기초구문 익히기](#기초구문-익히기)
   1. [1장. 프로그래밍을 시작합시다](#1장-프로그래밍을-시작합시다)
   2. [2장. 처음 만드는 C# 프로그램](#2장-처음-만드는-C-프로그램)
   3. [3장. 데이터 보관하기](#3장-데이터-보관하기)



## 기초구문 익히기

### 1장. 프로그래밍을 시작합시다

- 확장자

  - .sln : 솔루션. 관련 프로젝트 여러 개를 함께 관리할 수 있는 단위

  - .cproj : 프로젝트 파일

  - .cs : 소스코드

- 비주얼 스튜디오로 환경 설정

  - https://visualstudio.microsoft.com/ko/ - 다운로드 - Visual Studio Community 2022
  - 설치 옵션 : .NET 데스크톱 개발



### 2장. 처음 만드는 C# 프로그램

#### 이 장의 핵심개념

- "Hello World"를 출력하는 첫 예제 프로그램을 만들고 실행합니다.
- 첫 예제 프로그램을 분석하며 C# 코드의 얼개를 파악합니다.
- C#언어와 CLR의 관계에 대해 알아봅니다.



#### 2.1 Hello, WORLD!

- 실행 과정
  - 비주얼 스튜디오 실행
  - 새 프로젝트 만들기
  - 콘솔 앱 선택
  - 프로젝트 이름 Hello
  - 솔루션 탐색기에 'Program.cs' 항목을 선택 후 'MainApp.cs'로 변경
  - 코드 작성
  - 코드 컴파일
    - ctrl + shift + B
    - 빌드 - 솔루션 빌드
  - 실행 파일이 제대로 생성됐는지 확인
    - 솔루션 탐색기에서 Hello 솔루션 항목이나 프로젝트 항목 위에서 오른쪽 마우스 버튼 클릭 - 파일 탐색기에서 폴더 열기
    - 프로젝트 디렉토리 이동
    - bin/Debug/net6.0 디렉터리 안에 Hello.exe 만들어진 것 확인
  - 프로그램 시험
    - 명령 프롬프트 실행
      - windows + R
    - 실행창 띄우고 cmd 타이핑
    - 해당 파일 위치한 파일 탐색기 주소창을 선택하고 "ctrl+C"키를 입력해 실행 팡리이 있는 경로를 클립복드에 복사
    - 명령 프롬프트 창에 cd 입력하고 오른쪽 마우스 버튼 클릭
    - enter 키 입력하여 실행 파일이 있는 곳으로 이동
    - Hello.exe 프로그램 실행
      - Hello.exe 또는 확장자를 뺀 Hello 만 입력해도 됨



#### 2.2 첫 번째 프로그램 뜯어보기

##### 2.2.1 using System;

- 키워드 : C# 언어의 규격에 미리 정의되어 있는 특별한 단어
- using : C# 키워드 중 하나. 뒤에 따라오는 System을 사용하겠다는 것.
- System : C#코드가 기본적으로 필요로 하는 클래스를 담고 있는 네임스페이스
- using System : System 네임스페이스 안에 있는 클래스를 사용하겠다고 컴파일러에 알리는 역할
- ; : 문장의 끝을 알리는 기호



##### 2.2.2 using static System.Console;

- using static : 어떤 데이터 형식의 정적 멤버를 데이터 형식의 이름을 명시하지 않고 참조하겠다고 선언하는 기능



##### 2.2.3 namespace Hello{}

- 네임스페이스 : 성격이나 하는 일이 비슷한 클래스, 구조체, 인터페이스, 대리자, 열거 형식 등을 하나의 이름 아래 묶는 일을 함

- 네임스페이스를 만들 때는 namespace 키워드를 이용하며, 네임스페이스_이름 뒤에 따라오는 {괄호} 사이에는 이 네임스페이스에 소속되는 클래스 등이 들어감

- ```
  namespace 네임스페이스_이름
  {
  	// 클래스
  	// 구조체
  	// 인터페이스 등...
  }
  ```

- ```
  namespace Hello
  {
  	class MainApp
  	{
  	
  	}
  }
  ```

  - 다른 네임스페이스에서 MainApp 클래스를 사용하려면 using Hello; 문장을 이용해서 Hello 네임스페이스를 참조하거나 Hello.MainApp처럼 클래스가 소속되어 있는 네임스페이스와 클래스의 이름을 붙여줘야 함.



##### 2.2.4 class MainApp {}

- class MainApp 구문은 MainApp이라는 이름의 클래스를 만듦
- 클래스 : C#프로그램을 구성하는 기본 단위로서 데이터와 데이터를 처리하는 기능으로 이루어짐



##### 2.2.5 // 프로그램 실행이 시작되는 곳

- // : 한 줄로 끝나는 주석

- /* */ : 여러 줄로 이루어진 주석. 중첩해서 사용하면 주석이 깨질 위험이 있음



##### 2.2.6 static void Main(string[]args){}

- `static void Main(string[] args){}` : 메소드. 프로젝트의 진입점으로서 프로그램을 시작하면 실행되고, 이 메소드가 종료되면 프로그램도 역시 종료됨. 따라서 모든 프로그램들은 반드시 Main이라는 이름을 가진 메소드를 하나 가지고 있어야 함.
  - `static` : 한정자. 메소드나 변수 등을 수식
    - C#프로그램의 각 요소는 코드가 실행되는 시점에 비로소 메모리에 할당되는 반면, static 키워드로 수식되는 코드는 프로그램이 처음 구동될 때부터 진작에 메모리에 할당된다는 특징이 있음
    - 프로그램이 실행되면 CLR은 프로그램을 메모리에 올린 후 프로그램의 진입점을 찾는데, 이때 Main() 메소드가 static 키워드로 수식되어 있지 않다면 CLR은 진입점을 찾지 못했다는 에러 메시지를 남기고 프로그램을 종료시킬 것임.
  - `void` : 메소드의 반환 형식. 이 메소드가 어떤 결과도 돌려주지 않을 것이라는 것을 컴파일러에게 알려주는 기능
  - `Main` : 메소드 이름.
    - 메소드 이름 뒤에 있는 괄호와 그 사이에 있는 코드 : 메소드에 입력되는 매개변수
  - 코드 블록 : 메소드의 코드 블록은 메소드가 실행될 때 실행할 세부 코드를 담음.
    - 코드 블록이 열리는 곳{에서 메소드의 실행이 시작되고코드 블록이 닫히는 곳 }에서 메소드의 실행이 끝남.
    - Main() 메소드는 프로그램의 시작을 담당하는 특별한 메소드이기 때문에 Main() 메소드의 코드블록이 끝나면 프로그램도 같이 종료됨.
- 메소드 : 객체지향 프로그램이 세계에서 함수를 일컫는 말
- 한정자 : 문장의 다른 요소를 꾸며주는 역할을 하는 성분
- CLR : C#으로 만든 프로그램이 실행되는 환경

- 진입점 : 프로그램이 시작되는 첫 번째 코드



##### 2.2.7 if(args.Length == 0){}

- Hello.exe는 실행할 때 매개변수를 요구하는데 "Hello.exe"로만 실행하면 사용법에 대한 설명을 출력하고 종료
  - if문은 조건을 평가해서 프로그램의 흐름을 결정하는 코드인데 매개변수 목록의 길이가 0일 때 안내문을 출력하고 프로그램을 종료시킴



#### 2.3 CLR에 대하여

- C#으로 만든 프로그램은 CLR 위에서 실행이 됨
- 네이티브 코드로 작성된 프로그램들은 운영체제가 직접 실행할 수 있지만, C# 컴파일러가 만들어낸 실행 파일은 하드웨어가 이해할 수 없는 코드로 구성되어 있기 때문에 실행할 수 없음.
- C# 컴파일러는 C# 소스코드를 컴파일해서 IL이라는 중간 언어로 작성된 실행파일을 만들어 냄. 사용자가 이 팡리을 실행시키면 CLR이 중간 코드를 읽어 들여 다시 하드웨어가 이해할 수 있는 네이티브 코드로 컴파일한 후 실행시킴. 이것을 JIT 컴파일이라고 부름. JIT 컴파일이란 실행에 필요한 코드를 실행할 때마다 실시간으로 컴파일해서 실행한다는 뜻.
  - 장점 : 플랫폼에 최적화된 코드를 만들어낸다는 것
  - 단점 : 실행 시 이루어지는 컴파일 비용의 부담
- C#이나 기타 언어들을 동작시키는 환경 기능 외에도, 프로그램의 오류가 발생했을 때 이를 처리하도록 도와주는 기능, 언어간의 상속 지원, COM과의 상호 운영성 지원, 그리고 자동 메모리 관리 등의 기능을 제공. 이 중에서 자동 메모리 관리는 가비지 셀렉션이라고 하는데 프로그램에서 더 이상 사용하지 않는 메모리를 쓰레기로 간주하고 수거하는 기능.



### 3장. 데이터 보관하기

#### 이 장의 핵심개념

- 데이터 형식이 무엇인지 이해합니다.
- 값 형식과 참조 형식의 차이를 이해합니다.
- 기본 데이터 형식의 사용 방법을 익힙니다.
- 상수가 무엇인지 알아보고 사용 방법을 익힙니다.
- Nullable 형식을 이해합니다.
- C#의 데이터 형식과 공용 형식 시스템의 관계를 이해합니다.



#### 3.1 다양한 데이터의 종류

- C#은 기본 데이터 형식을 부품으로 삼아 구성되는 복합 데이터 형식을 지원
  - 복합 데이터 형식의 종류에는 구조체, 클래스, 배열 등이 있음
- 데이터 형식은 기본 데이터 형식과 복합 데이터 형식으로 분류하는 동시에, 값 형식과 참조 형식으로도 분류할 수 있음.



#### 3.2 변수

- 코드에서 변수 : 값을 대입시켜 변화시킬 수 있는 요소

- 메모리 쪽에서 보는 변수 : 데이터를 담는 일정 크기의 공간

- 변수는 다음과 같이 선언함

  - `int x;`
    - int : 데이터 형식
    - x : 식별자(변수의 이름)
    - 문장 종결을 위해 세미콜론을 붙여서 해당 문장의 끝을 컴파일러에 알려줌
    - 이렇게 하면 컴파일러는 int 형식을 위해 메모리 공간을 할당하고 이 공간을 x라는 식별자가 사용할 수 있도록 준비함

- 선언된 변수 x에는 대입 연산자를 통해 데이터를 입력할 수 있음

  - `x=100;`
    - x : 식별자
    - = : 대입 연산자
    - 100 : 데이터
    - 이 코드를 실행하고 나면 x를 위해 메모리 공간에 데이터 100이 기록됨.

- 어떤 변수는 태어나는 시점부터 특정ㅇ한 값을 갖고 있어야 하는 경우가 있음. 이런 경우에는 선언과 데이터 할당을 동시에 할 수 있음

  - ```
    int x; // 선언과
    x = 100; // 데이터 할당을 별도로 할 수도 있지만
    
    int x = 100; // 선언과 초기화를 한 번에 할 수도 있습니다.
    ```

- 변수 여러 개를 동시에 선언할 수도 있음.

  - 단, 동시에 선언하는 변수들은 데이터 형식이 같아야하며 각 식별자를 콤마(,)로 구분해줘야 함.

  - ```
    int a, b, c; // 같은 형식의 변수들은 동시에 선언할 수 있습니다.
    int x = 30, y = 40, z = 50; // 선언과 초기화를 한번에 하는 것도 여전히 가능합니다.
    ```

- 초기화 : 변수에 최초의 데이터를 할당하는 것을 의미

  - C#은 초기화 강제. 초기화되지 않은 변수를 사용하면 컴파일러가 에러 메시지를 내면서 실행 파일을 만들어주지 않음.

- 리터럴 : 사전에서는 "문자 그대로의"라는 뜻을 가진 형용사. 컴퓨터 과학에서는 고정값을 나타내는 표기법

  - `int x = 30;`
    - x : 변수
    - 30 : 리터럴



#### 3.3 값 형식과 참조 형식

- 값 형식 : 변수가 값을 담는 데이터 형식
- 참조 형식 : 변소가 값 대신 갑싱 있는 곳의 위치(참조)를 담는 데이터 형식
- C#으로 작성한 프로그램이 사용하는 두 가지 메모리 영역
  - 스택 : 값 형식과 관련이 있는 것
  - 힙 : 참조 형식과 관련이 있는 것



##### 3.3.1 스택과 값 형식

- ```
  { // 코드 블록 시작
  	int a = 100;
  	int b = 200;
  	int c = 300;
  } // 코드 블록 끝
  ```

  - 코드에 선언된 세 변수 a, b, c는 차례대로 스택에 쌓였다가 코드 블록이 끝나면서 스택에서 걷혀 제거가 됨
  - 값 형식의 변수는 모두 이 스택에 저장됨.
  - 코드 블록 안에서 생성된 모든 값 형식의 변수들은 프로그램 실행이 중괄호  }를 만나면 메모리에서 제거됨

  

##### 3.3.2 힙과 참조 형식

- 힙 : 저장된 데이터를 스스로 제거하는 메커니즘을 갖고 잇지 않음. 대신 청소부를 따로 고용하고 있는데, 이것이 바로 CLR의 가비지 컬렉터

- 가비지 컬렉터는 프로그램 뒤에 숨어 동작하면서 힙에 더 이상 사용하지 않는 객체가 있으면 그 객체를 쓰레기로 간주하고 수거하는 기능을 함

- 스택에 쌓인 데이터들은 코드블록이 사라지는 시점에 함께 제거가 되는데 코드 블록이 끝나는 시점과 상관없이 데이터를 유지하고 싶을 때는 스택의 구조가 발목을 잡는 요소

- 원한다면 데이터를 살릴 수 있는 또 다른 메모리 영역을 CLR이 제공

- 참조 형식의 변수는 힙과 스택을 함께 이용

  - 힙 : 데이터 저장
  - 스택 : 데어터가 저장된 힙 메모리의 주소를 저장

- ```
  {
  	object a = 10;
  	object b = 20;
  }
  ```

  - CLR이 이 코드를 실행하면 실제 값 10과 20은 힙에 저장하고, a와 b는 값이 저장된 힙의 주소만 스택에 저장해둠
  - }를 만나는 곳에서 a와 b는 스택에서 사라짐. 힙에는 여전히 10과 20이 남아 있음. 이 데이터들은 CLR의 메모리 청소부인 가비지 컬렉터가 수거해감



#### 3.4 기본 데이터 형식

- C#이 제공하는 기본 데이터 형식 : 15가지
  - 숫자, 논리, 문자열, 오브젝트 형식
  - 문자열, 오브젝트 형식만 참조 형식
  - 나머지는 모두 값 형식



##### 3.4.1 숫자 데이터 형식

- C#은 15가지 기본 자료 형식 중 12가지를 숫자 데이터 형식으로 제공
- 12가지 형식은 다시 정수 계열, 부동 소수 계열, 소수 계열 이렇게 3가지로 나뉨



##### 정수 계열 형식

- 정수 데이터를 담기 위해 사용

- 12가지의 숫자 형식 중 9가지가 정수 계열 형식

- 9가지 정수 형식은 각각 크기와 담을 수 있는 데이터의 범위가 다른데, 코드에 사용될 데이터가 어느 정도의 범위에 있는지 판단한 뒤 적절한 데이터 형식을 선택함으로써 메모리를 효율적으로 사용할 수 있게 하기 위함

- | 데이터 형식 |             설명              | 크기(바이트) |                 담을 수 있는 값의 범위                 |
  | :---------: | :---------------------------: | :----------: | :----------------------------------------------------: |
  |    byte     |        부호 없는 정수         |   1(8비트)   |                        0 ~ 255                         |
  |    sbyte    |       signed byte 정수        |   1(8비트)   |                       -128 ~ 127                       |
  |    short    |             정수              |  2(16비트)   |                    -32,768 ~ 32,767                    |
  |   ushort    | unsigned short 부호 없는 정수 |  2(16비트)   |                       0 ~ 65,535                       |
  |     int     |             정수              |  4(32비트)   |             -2,147,483,648 ~ 2,147,483,647             |
  |    uint     |  unsigned int 부호 없는 정수  |  4(32비트)   |                   0 ~ 4,294,967,295                    |
  |    long     |             정수              |  8(64비트)   | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |
  |    ulong    | unsigned long 부호 없는 정수  |  8(64비트)   |             0 ~ 18,446,744,073,709,551,615             |
  |    char     |         유니코드 문자         |  2(16비트)   |                                                        |

  

##### 정수 형식 예제 프로그램

- 큰 자릿수의 정수 리터럴을 타이핑할 때 자릿수 구분자(_)를 이용하면 편리하다.

- 바이트
  - 거의 모든 컴퓨터는 8비트를 1바이트 취급
  - 1바이트는 8개의 0과 1로 구성되는 데이터 덩어리
  - 바이트 단위가 중요한 이유는 이것이 컴퓨터가 데이터를 다루는 기본 단위이기 때문
- 비타민 퀴즈 3-1
  - ![3_1](md-images/3_1.PNG)



##### 2진수, 10진수, 16진수 리터럴

- 코드에도 10진수를 자주 사용하지만 경우에 따라서는 2진수와 16진수를 다룰 일이 종종 새김
- C#은 2진수 리터럴을 위해 0b, 16진수 레터럴을 위해 0X(또는 0x) 접두사를 제공

- 자릿수 구분자는 10진수뿐 아니라 2진수와 16진수에 대해서도 사용할 수 있음



##### 부호 있는 정수와 부호 없는 정수 

- sbyte, short, int, long은 부호있는 정수
- byte, ushort, uint, ulong은 그냥 (부호 없는) 정수
- byte는 비트 8개 모두를 수 표현에 사용하는 반면 sbyte는 8갸 즁 7개 비트만 수 표현에 사용하고 첫 번째 비트는 부호를 처리하는 데 사용. sbyte의 첫 번째 비트는 부호 비트.
- 2의 보수법
  - 번저 수 부분 비트를 채운다.
  - 전체 비트를 반전시킨다.
  - 반전된 비트에 1을 더한다.



##### 데이터가 넘쳐 흘러요

- 오버플로 : 변수가 데이터 형식의 크기를 넘어선 값을 담으면 넘침.
- 각 데이터 형식의 최대값을 넘어가는 데이터를 저장할 때는 오버플로가 일어나지만, 최저값보다 작은 데이터를 저장하면 언더플로우가 일어남



##### char

- 정수 계열 형식



##### 3.4.2 부동 소수점 형식

- 소수점이 고정되어 있지않고 움직이면서 수를 표현한다는 뜻에서 지어진 이름

- 소수점을 가만두지 않고 옮기는 이유 : 소수점을 이동시켜 수를 표현하면 고정시켰을 때보다 더 제한된 비트를 이용해서 훨씬 넓은 범위의 값을 표현할 수 있기 때문

- 부동 소수점 형식은 소수점을 표현하기 위해 일부 비트를 사용하기 때문에 같은 크기의 정수 계열 형식과 같으느 크기의 수를 표현할 수 없음

- 부동 소수점 형식은 산술 연산 과정이 정수 계열 형식보다 복잡해서 느림.

- | 데이터 형식 |                             설명                             | 크기(바이트) | 범위                                         |
  | :---------: | :----------------------------------------------------------: | :----------: | -------------------------------------------- |
  |    float    | 단일 정밀도 부동 소수점 형식<br />(7개의 자릿수만 다룰 수 있음) |  4(32비트)   | -3.402823e38 ~ 3.402823e38                   |
  |   double    | 복수 정밀도 부동 소수점 형식<br />(15~16개의 자릿수를 다룰 수 있음) |  8(64비트)   | -1.79769313486232e308 ~ 1.79769313486232e308 |



##### decimal 형식

- 실수를 다루는 데이터 형식.

- 부동 소수점과는 다른 방식으로 소수를 다루며 정밀도가 훨씬 높음.

- | 데이터 형식 |                   설명                   | 크기(바이트) |            범위             |
  | :---------: | :--------------------------------------: | :----------: | :-------------------------: |
  |   decimal   | 29자리 데이터를 표현할 수 있는 소수 형식 | 16(128비트)  | ± 1.0*10e-28 ~ ±7.9 * 10e28 |

  



 
