# 이것이 C#이다

## 목차

1. [기초구문 익히기](#기초구문-익히기)
   1. [1장. 프로그래밍을 시작합시다](#1장-프로그래밍을-시작합시다)
   2. [2장. 처음 만드는 C# 프로그램](#2장-처음-만드는-C-프로그램)
   3. [3장. 데이터 보관하기](#3장-데이터-보관하기)
   4. [4장. 데이터를 가공하는 연산자](#3장-데이터를-가공하는-연산자)
   5. [5장. 코드의 흐름 제어하기](#5장-코드의-흐름-제어하기)
   6. [6장. 메소드로 코드 간추리기](#6장-메소드로-코드-간추리기)
   7. [7장. 클래스](#7장-클래스)



## 기초구문 익히기

### 1장. 프로그래밍을 시작합시다

- 확장자

  - .sln : 솔루션. 관련 프로젝트 여러 개를 함께 관리할 수 있는 단위

  - .cproj : 프로젝트 파일

  - .cs : 소스코드

- 비주얼 스튜디오로 환경 설정

  - https://visualstudio.microsoft.com/ko/ - 다운로드 - Visual Studio Community 2022
  - 설치 옵션 : .NET 데스크톱 개발



### 2장. 처음 만드는 C# 프로그램

#### 이 장의 핵심개념

- "Hello World"를 출력하는 첫 예제 프로그램을 만들고 실행합니다.
- 첫 예제 프로그램을 분석하며 C# 코드의 얼개를 파악합니다.
- C#언어와 CLR의 관계에 대해 알아봅니다.



#### 2.1 Hello, WORLD!

- 실행 과정
  - 비주얼 스튜디오 실행
  - 새 프로젝트 만들기
  - 콘솔 앱 선택
  - 프로젝트 이름 Hello
  - 솔루션 탐색기에 'Program.cs' 항목을 선택 후 'MainApp.cs'로 변경
  - 코드 작성
  - 코드 컴파일
    - ctrl + shift + B
    - 빌드 - 솔루션 빌드
  - 실행 파일이 제대로 생성됐는지 확인
    - 솔루션 탐색기에서 Hello 솔루션 항목이나 프로젝트 항목 위에서 오른쪽 마우스 버튼 클릭 - 파일 탐색기에서 폴더 열기
    - 프로젝트 디렉토리 이동
    - bin/Debug/net6.0 디렉터리 안에 Hello.exe 만들어진 것 확인
  - 프로그램 시험
    - 명령 프롬프트 실행
      - windows + R
    - 실행창 띄우고 cmd 타이핑
    - 해당 파일 위치한 파일 탐색기 주소창을 선택하고 "ctrl+C"키를 입력해 실행 팡리이 있는 경로를 클립복드에 복사
    - 명령 프롬프트 창에 cd 입력하고 오른쪽 마우스 버튼 클릭
    - enter 키 입력하여 실행 파일이 있는 곳으로 이동
    - Hello.exe 프로그램 실행
      - Hello.exe 또는 확장자를 뺀 Hello 만 입력해도 됨



#### 2.2 첫 번째 프로그램 뜯어보기

##### 2.2.1 using System;

- 키워드 : C# 언어의 규격에 미리 정의되어 있는 특별한 단어
- using : C# 키워드 중 하나. 뒤에 따라오는 System을 사용하겠다는 것.
- System : C#코드가 기본적으로 필요로 하는 클래스를 담고 있는 네임스페이스
- using System : System 네임스페이스 안에 있는 클래스를 사용하겠다고 컴파일러에 알리는 역할
- ; : 문장의 끝을 알리는 기호



##### 2.2.2 using static System.Console;

- using static : 어떤 데이터 형식의 정적 멤버를 데이터 형식의 이름을 명시하지 않고 참조하겠다고 선언하는 기능



##### 2.2.3 namespace Hello{}

- 네임스페이스 : 성격이나 하는 일이 비슷한 클래스, 구조체, 인터페이스, 대리자, 열거 형식 등을 하나의 이름 아래 묶는 일을 함

- 네임스페이스를 만들 때는 namespace 키워드를 이용하며, 네임스페이스_이름 뒤에 따라오는 {괄호} 사이에는 이 네임스페이스에 소속되는 클래스 등이 들어감

- ```
  namespace 네임스페이스_이름
  {
  	// 클래스
  	// 구조체
  	// 인터페이스 등...
  }
  ```

- ```
  namespace Hello
  {
  	class MainApp
  	{
  	
  	}
  }
  ```

  - 다른 네임스페이스에서 MainApp 클래스를 사용하려면 using Hello; 문장을 이용해서 Hello 네임스페이스를 참조하거나 Hello.MainApp처럼 클래스가 소속되어 있는 네임스페이스와 클래스의 이름을 붙여줘야 함.



##### 2.2.4 class MainApp {}

- class MainApp 구문은 MainApp이라는 이름의 클래스를 만듦
- 클래스 : C#프로그램을 구성하는 기본 단위로서 데이터와 데이터를 처리하는 기능으로 이루어짐



##### 2.2.5 // 프로그램 실행이 시작되는 곳

- // : 한 줄로 끝나는 주석

- /* */ : 여러 줄로 이루어진 주석. 중첩해서 사용하면 주석이 깨질 위험이 있음



##### 2.2.6 static void Main(string[]args){}

- `static void Main(string[] args){}` : 메소드. 프로젝트의 진입점으로서 프로그램을 시작하면 실행되고, 이 메소드가 종료되면 프로그램도 역시 종료됨. 따라서 모든 프로그램들은 반드시 Main이라는 이름을 가진 메소드를 하나 가지고 있어야 함.
  - `static` : 한정자. 메소드나 변수 등을 수식
    - C#프로그램의 각 요소는 코드가 실행되는 시점에 비로소 메모리에 할당되는 반면, static 키워드로 수식되는 코드는 프로그램이 처음 구동될 때부터 진작에 메모리에 할당된다는 특징이 있음
    - 프로그램이 실행되면 CLR은 프로그램을 메모리에 올린 후 프로그램의 진입점을 찾는데, 이때 Main() 메소드가 static 키워드로 수식되어 있지 않다면 CLR은 진입점을 찾지 못했다는 에러 메시지를 남기고 프로그램을 종료시킬 것임.
  - `void` : 메소드의 반환 형식. 이 메소드가 어떤 결과도 돌려주지 않을 것이라는 것을 컴파일러에게 알려주는 기능
  - `Main` : 메소드 이름.
    - 메소드 이름 뒤에 있는 괄호와 그 사이에 있는 코드 : 메소드에 입력되는 매개변수
  - 코드 블록 : 메소드의 코드 블록은 메소드가 실행될 때 실행할 세부 코드를 담음.
    - 코드 블록이 열리는 곳{에서 메소드의 실행이 시작되고코드 블록이 닫히는 곳 }에서 메소드의 실행이 끝남.
    - Main() 메소드는 프로그램의 시작을 담당하는 특별한 메소드이기 때문에 Main() 메소드의 코드블록이 끝나면 프로그램도 같이 종료됨.
- 메소드 : 객체지향 프로그램이 세계에서 함수를 일컫는 말
- 한정자 : 문장의 다른 요소를 꾸며주는 역할을 하는 성분
- CLR : C#으로 만든 프로그램이 실행되는 환경

- 진입점 : 프로그램이 시작되는 첫 번째 코드



##### 2.2.7 if(args.Length == 0){}

- Hello.exe는 실행할 때 매개변수를 요구하는데 "Hello.exe"로만 실행하면 사용법에 대한 설명을 출력하고 종료
  - if문은 조건을 평가해서 프로그램의 흐름을 결정하는 코드인데 매개변수 목록의 길이가 0일 때 안내문을 출력하고 프로그램을 종료시킴



#### 2.3 CLR에 대하여

- C#으로 만든 프로그램은 CLR 위에서 실행이 됨
- 네이티브 코드로 작성된 프로그램들은 운영체제가 직접 실행할 수 있지만, C# 컴파일러가 만들어낸 실행 파일은 하드웨어가 이해할 수 없는 코드로 구성되어 있기 때문에 실행할 수 없음.
- C# 컴파일러는 C# 소스코드를 컴파일해서 IL이라는 중간 언어로 작성된 실행파일을 만들어 냄. 사용자가 이 팡리을 실행시키면 CLR이 중간 코드를 읽어 들여 다시 하드웨어가 이해할 수 있는 네이티브 코드로 컴파일한 후 실행시킴. 이것을 JIT 컴파일이라고 부름. JIT 컴파일이란 실행에 필요한 코드를 실행할 때마다 실시간으로 컴파일해서 실행한다는 뜻.
  - 장점 : 플랫폼에 최적화된 코드를 만들어낸다는 것
  - 단점 : 실행 시 이루어지는 컴파일 비용의 부담
- C#이나 기타 언어들을 동작시키는 환경 기능 외에도, 프로그램의 오류가 발생했을 때 이를 처리하도록 도와주는 기능, 언어간의 상속 지원, COM과의 상호 운영성 지원, 그리고 자동 메모리 관리 등의 기능을 제공. 이 중에서 자동 메모리 관리는 가비지 셀렉션이라고 하는데 프로그램에서 더 이상 사용하지 않는 메모리를 쓰레기로 간주하고 수거하는 기능.



### 3장. 데이터 보관하기

#### 이 장의 핵심개념

- 데이터 형식이 무엇인지 이해합니다.
- 값 형식과 참조 형식의 차이를 이해합니다.
- 기본 데이터 형식의 사용 방법을 익힙니다.
- 상수가 무엇인지 알아보고 사용 방법을 익힙니다.
- Nullable 형식을 이해합니다.
- C#의 데이터 형식과 공용 형식 시스템의 관계를 이해합니다.



#### 3.1 다양한 데이터의 종류

- C#은 기본 데이터 형식을 부품으로 삼아 구성되는 복합 데이터 형식을 지원
  - 복합 데이터 형식의 종류에는 구조체, 클래스, 배열 등이 있음
- 데이터 형식은 기본 데이터 형식과 복합 데이터 형식으로 분류하는 동시에, 값 형식과 참조 형식으로도 분류할 수 있음.



#### 3.2 변수

- 코드에서 변수 : 값을 대입시켜 변화시킬 수 있는 요소

- 메모리 쪽에서 보는 변수 : 데이터를 담는 일정 크기의 공간

- 변수는 다음과 같이 선언함

  - `int x;`
    - int : 데이터 형식
    - x : 식별자(변수의 이름)
    - 문장 종결을 위해 세미콜론을 붙여서 해당 문장의 끝을 컴파일러에 알려줌
    - 이렇게 하면 컴파일러는 int 형식을 위해 메모리 공간을 할당하고 이 공간을 x라는 식별자가 사용할 수 있도록 준비함

- 선언된 변수 x에는 대입 연산자를 통해 데이터를 입력할 수 있음

  - `x=100;`
    - x : 식별자
    - = : 대입 연산자
    - 100 : 데이터
    - 이 코드를 실행하고 나면 x를 위해 메모리 공간에 데이터 100이 기록됨.

- 어떤 변수는 태어나는 시점부터 특정ㅇ한 값을 갖고 있어야 하는 경우가 있음. 이런 경우에는 선언과 데이터 할당을 동시에 할 수 있음

  - ```
    int x; // 선언과
    x = 100; // 데이터 할당을 별도로 할 수도 있지만
    
    int x = 100; // 선언과 초기화를 한 번에 할 수도 있습니다.
    ```

- 변수 여러 개를 동시에 선언할 수도 있음.

  - 단, 동시에 선언하는 변수들은 데이터 형식이 같아야하며 각 식별자를 콤마(,)로 구분해줘야 함.

  - ```
    int a, b, c; // 같은 형식의 변수들은 동시에 선언할 수 있습니다.
    int x = 30, y = 40, z = 50; // 선언과 초기화를 한번에 하는 것도 여전히 가능합니다.
    ```

- 초기화 : 변수에 최초의 데이터를 할당하는 것을 의미

  - C#은 초기화 강제. 초기화되지 않은 변수를 사용하면 컴파일러가 에러 메시지를 내면서 실행 파일을 만들어주지 않음.

- 리터럴 : 사전에서는 "문자 그대로의"라는 뜻을 가진 형용사. 컴퓨터 과학에서는 고정값을 나타내는 표기법

  - `int x = 30;`
    - x : 변수
    - 30 : 리터럴



#### 3.3 값 형식과 참조 형식

- 값 형식 : 변수가 값을 담는 데이터 형식
- 참조 형식 : 변소가 값 대신 갑싱 있는 곳의 위치(참조)를 담는 데이터 형식
- C#으로 작성한 프로그램이 사용하는 두 가지 메모리 영역
  - 스택 : 값 형식과 관련이 있는 것
  - 힙 : 참조 형식과 관련이 있는 것



##### 3.3.1 스택과 값 형식

- ```
  { // 코드 블록 시작
  	int a = 100;
  	int b = 200;
  	int c = 300;
  } // 코드 블록 끝
  ```

  - 코드에 선언된 세 변수 a, b, c는 차례대로 스택에 쌓였다가 코드 블록이 끝나면서 스택에서 걷혀 제거가 됨
  - 값 형식의 변수는 모두 이 스택에 저장됨.
  - 코드 블록 안에서 생성된 모든 값 형식의 변수들은 프로그램 실행이 중괄호  }를 만나면 메모리에서 제거됨

  

##### 3.3.2 힙과 참조 형식

- 힙 : 저장된 데이터를 스스로 제거하는 메커니즘을 갖고 잇지 않음. 대신 청소부를 따로 고용하고 있는데, 이것이 바로 CLR의 가비지 컬렉터

- 가비지 컬렉터는 프로그램 뒤에 숨어 동작하면서 힙에 더 이상 사용하지 않는 객체가 있으면 그 객체를 쓰레기로 간주하고 수거하는 기능을 함

- 스택에 쌓인 데이터들은 코드블록이 사라지는 시점에 함께 제거가 되는데 코드 블록이 끝나는 시점과 상관없이 데이터를 유지하고 싶을 때는 스택의 구조가 발목을 잡는 요소

- 원한다면 데이터를 살릴 수 있는 또 다른 메모리 영역을 CLR이 제공

- 참조 형식의 변수는 힙과 스택을 함께 이용

  - 힙 : 데이터 저장
  - 스택 : 데어터가 저장된 힙 메모리의 주소를 저장

- ```
  {
  	object a = 10;
  	object b = 20;
  }
  ```

  - CLR이 이 코드를 실행하면 실제 값 10과 20은 힙에 저장하고, a와 b는 값이 저장된 힙의 주소만 스택에 저장해둠
  - }를 만나는 곳에서 a와 b는 스택에서 사라짐. 힙에는 여전히 10과 20이 남아 있음. 이 데이터들은 CLR의 메모리 청소부인 가비지 컬렉터가 수거해감



#### 3.4 기본 데이터 형식

- C#이 제공하는 기본 데이터 형식 : 15가지
  - 숫자, 논리, 문자열, 오브젝트 형식
  - 문자열, 오브젝트 형식만 참조 형식
  - 나머지는 모두 값 형식



##### 3.4.1 숫자 데이터 형식

- C#은 15가지 기본 자료 형식 중 12가지를 숫자 데이터 형식으로 제공
- 12가지 형식은 다시 정수 계열, 부동 소수 계열, 소수 계열 이렇게 3가지로 나뉨



##### 정수 계열 형식

- 정수 데이터를 담기 위해 사용

- 12가지의 숫자 형식 중 9가지가 정수 계열 형식

- 9가지 정수 형식은 각각 크기와 담을 수 있는 데이터의 범위가 다른데, 코드에 사용될 데이터가 어느 정도의 범위에 있는지 판단한 뒤 적절한 데이터 형식을 선택함으로써 메모리를 효율적으로 사용할 수 있게 하기 위함

- | 데이터 형식 |             설명              | 크기(바이트) |                 담을 수 있는 값의 범위                 |
  | :---------: | :---------------------------: | :----------: | :----------------------------------------------------: |
  |    byte     |        부호 없는 정수         |   1(8비트)   |                        0 ~ 255                         |
  |    sbyte    |       signed byte 정수        |   1(8비트)   |                       -128 ~ 127                       |
  |    short    |             정수              |  2(16비트)   |                    -32,768 ~ 32,767                    |
  |   ushort    | unsigned short 부호 없는 정수 |  2(16비트)   |                       0 ~ 65,535                       |
  |     int     |             정수              |  4(32비트)   |             -2,147,483,648 ~ 2,147,483,647             |
  |    uint     |  unsigned int 부호 없는 정수  |  4(32비트)   |                   0 ~ 4,294,967,295                    |
  |    long     |             정수              |  8(64비트)   | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |
  |    ulong    | unsigned long 부호 없는 정수  |  8(64비트)   |             0 ~ 18,446,744,073,709,551,615             |
  |    char     |         유니코드 문자         |  2(16비트)   |                                                        |

  

##### 정수 형식 예제 프로그램

- 큰 자릿수의 정수 리터럴을 타이핑할 때 자릿수 구분자(_)를 이용하면 편리하다.

- 바이트
  - 거의 모든 컴퓨터는 8비트를 1바이트 취급
  - 1바이트는 8개의 0과 1로 구성되는 데이터 덩어리
  - 바이트 단위가 중요한 이유는 이것이 컴퓨터가 데이터를 다루는 기본 단위이기 때문
- 비타민 퀴즈 3-1
  - ![3_1](md-images/3_1.PNG)



##### 2진수, 10진수, 16진수 리터럴

- 코드에도 10진수를 자주 사용하지만 경우에 따라서는 2진수와 16진수를 다룰 일이 종종 새김
- C#은 2진수 리터럴을 위해 0b, 16진수 레터럴을 위해 0X(또는 0x) 접두사를 제공

- 자릿수 구분자는 10진수뿐 아니라 2진수와 16진수에 대해서도 사용할 수 있음



##### 부호 있는 정수와 부호 없는 정수 

- sbyte, short, int, long은 부호있는 정수
- byte, ushort, uint, ulong은 그냥 (부호 없는) 정수
- byte는 비트 8개 모두를 수 표현에 사용하는 반면 sbyte는 8갸 즁 7개 비트만 수 표현에 사용하고 첫 번째 비트는 부호를 처리하는 데 사용. sbyte의 첫 번째 비트는 부호 비트.
- 2의 보수법
  - 번저 수 부분 비트를 채운다.
  - 전체 비트를 반전시킨다.
  - 반전된 비트에 1을 더한다.



##### 데이터가 넘쳐 흘러요

- 오버플로 : 변수가 데이터 형식의 크기를 넘어선 값을 담으면 넘침.
- 각 데이터 형식의 최대값을 넘어가는 데이터를 저장할 때는 오버플로가 일어나지만, 최저값보다 작은 데이터를 저장하면 언더플로우가 일어남



##### char

- 정수 계열 형식



##### 3.4.2 부동 소수점 형식

- 소수점이 고정되어 있지않고 움직이면서 수를 표현한다는 뜻에서 지어진 이름

- 소수점을 가만두지 않고 옮기는 이유 : 소수점을 이동시켜 수를 표현하면 고정시켰을 때보다 더 제한된 비트를 이용해서 훨씬 넓은 범위의 값을 표현할 수 있기 때문

- 부동 소수점 형식은 소수점을 표현하기 위해 일부 비트를 사용하기 때문에 같은 크기의 정수 계열 형식과 같으느 크기의 수를 표현할 수 없음

- 부동 소수점 형식은 산술 연산 과정이 정수 계열 형식보다 복잡해서 느림.

- | 데이터 형식 |                             설명                             | 크기(바이트) | 범위                                         |
  | :---------: | :----------------------------------------------------------: | :----------: | -------------------------------------------- |
  |    float    | 단일 정밀도 부동 소수점 형식<br />(7개의 자릿수만 다룰 수 있음) |  4(32비트)   | -3.402823e38 ~ 3.402823e38                   |
  |   double    | 복수 정밀도 부동 소수점 형식<br />(15~16개의 자릿수를 다룰 수 있음) |  8(64비트)   | -1.79769313486232e308 ~ 1.79769313486232e308 |



##### decimal 형식

- 실수를 다루는 데이터 형식.

- 부동 소수점과는 다른 방식으로 소수를 다루며 정밀도가 훨씬 높음.

- | 데이터 형식 |                   설명                   | 크기(바이트) |            범위             |
  | :---------: | :--------------------------------------: | :----------: | :-------------------------: |
  |   decimal   | 29자리 데이터를 표현할 수 있는 소수 형식 | 16(128비트)  | ± 1.0*10e-28 ~ ±7.9 * 10e28 |

  

##### 3.4.3 문자 형식과 문자열 형식

- string 형식은 정해진 크기나 담을 수 있는 데이터의 범위가 따로 정혀져 있지 않음.
- 변수가 담는 텍스트의 양에 따라 그 크기가 달라지기 때문
- char 형식은 개별 문자를 표현하기 위해, string 형식은 문자열을 표현하기 위해 사용
- 개별 문자를 다룰 때는 '작은 따옴표', 문자열을 다룰 때는 "큰 따옴표"로 표시

 

##### 3.4.4 논리 형식

- | 데이터 형식 |   설명    | 크기(바이트) |    범위     |
  | :---------: | :-------: | :----------: | :---------: |
  |    bool     | 논리 형식 |   1(8비트)   | true, false |



##### 3.4.5 object 형식

- C#은 모든 데이터 형식이 자동으로 object 형식으로부터 상속받게 함.
- object 형식이 모든 데이터 형식의 조상이 됨.



##### 3.4.6 박싱과 언박싱

- object 형식은 참조 형식이기 때문에 힙에 데이터를 할당
- int 형식이나 double 형식은 값형식이기 때문에 스택에 데이터를 할당
- object 형식은 값 형식의 데이터를 힙에 할당하기 위한 박싱 기능을 제공
- 박싱된 값을 꺼내 값 형식 변수에 저장하는 과정을 언박싱



##### 3.4.7 데이터 형식 바꾸기

- 변수를 다른 데이터 형식의 변수에 옮겨 담는 것을 형식 변환이라고 함
  - 크기(표현 범위)가 서로 다른 정수 형식 사이의 변환
  - 크기(표현 범위)가 서로 다른 부동 소수점 형식 사이의 변환
  - 부호 있는 정수 형식과 부호 없는 정수 형식 사이의 변환
  - 부동 소수점 형식과 정수 형식 사이의 변환
  - 문자열과 숫자 사이의 변환



#### 3.5 상수와 열거 형식

- 상수와 열거 형식을 변수 대신 사용하면 컴파일러가 소스 코드를 컴파일 할 떄 프로그래머의 실수를 잡아 알려주고, 프로그램의 버그도 줄여줌.



##### 3.5.1 상수 - 전 언제나 변하지 않을 거예요

- 데이터 형식 앞에 const 키워드가 위치하고 상수가 가져야 하는 데이터를 반드시 대입해줘야 함.
- 상수 선언 형식
  - `const 자료형 상수명 = "값"`

- 상수의 값을 바꾸려고 하면?  컴파일러가 에러메시지를 쏟아놓음



##### 3.5.2 열거 형식 - 여러 개의 상수를 정리합시다

- 같은 범주에 속하는 여러 개의 상수를 선언할 때 유용
- `enum 열거 형식명 : 기반자료형 {상수1, 상수2, 상수3, ...}`
  - 기반자료형은 정수 계열만 사용할 수 있으며, 생략할 경우 컴파일러가 int를 기반자료형으로 사용



#### 3.6 Nullable 형식

- int 형식의 변수를 선언하면 4바이트의 메모리가 할당되는데 C# 컴파일러는 이 메모리 공간에 반드시 어떤 값이든 넣도록 강제. 원하는 대로 해주지 않으면 C# 컴파일러는 실행 파일을 내주지 않음
- 0이 아닌 비어 있는 변수, 즉 null 상태인 변수가 필요할 때는 변수에게 할당된 메모리 공간을 비워둘 수 있도록 Nullable 형식을 사용하면 됨

- Nullable 형식을 사용할 수 있는 경우는 값 형식에 한해서. 참조형식은 X.
- `데이터 형식? 변수이름;`

- 모든 Nullable 형식은 HasValue와 Value 두 가지 속성을 갖고 있음
  - HasValue : 해당 변수가 값을 갖고 있는지 또는 그렇지 않은지
  - Value : 변수에 담겨있는 값
- 어떤 Nullable 형식 변수의 HasValue 속성이 False 값을 갖고 있다면 그 변수는 비어 있다는 뜻. 이 변수를 Value 속성을 이용하여 값을 꺼내려 시도하면 CLR은 InvalidOperation Excepting 예외를 띄울 것음



#### 3.7 var: 데이터 형식을 알아서 파악하는 똑똑한 C# 컴파일러

- var 키워드를 통해서 약한 형식 검사를 하는 언어의 편리함 지원
- var를 사용해서 변수를 선언하면 컴파일러가 자동으로 해당 변수의 형식 지정
- var는 지역 변수로만 사용할 수 있음. 지역 변수란 코드 블록 안에서 선언되는 변수
- 클래스의 필드를 선언할 때는 반드시 명시적 형식을 선언해야 함.



#### 3.8 공용 형식 시스템

- 공용 형식 시스템은 "모두가 함께 사용하는 데이터 형식 체계"라는 의미
- .NET 언어들이라면 반드시 따라야 하는 데이터 형식 표준



#### 3.9 문자열 다루기

##### 3.9.1 문자열 안에서 찾기

- |    메소드     |                             설명                             |
  | :-----------: | :----------------------------------------------------------: |
  |   IndexOf()   | 현재 문자열 내에서 찾고자 하는 지정된 문자 또는 문자열의 위치를 찾습니다. |
  | LastIndexOf() | 현재 문자열 내에서 찾고자 하는 지정된 문자 또는 문자열의 위치를 뒤에서부터 찾습니다. |
  | StartsWith()  |    현재 문자열이 지정된 문자열로 시작하는지를 평가합니다.    |
  |  EndsWith()   |     현재 문자열이 지정된 문자열로 끝나는지를 평가합니다.     |
  |  Contains()   |    현재 문자열이 지정된 문자열을 포함하는지를 평가합니다.    |
  |   Replace()   | 현재 문자열에서 지정된 문자열이 다른 지정된 문자열로 모두 바뀐 새 문자열을 반환합니다. |



##### 3.9.2 문자열 변형하기

- |   메소드    |                             설명                             |
  | :---------: | :----------------------------------------------------------: |
  |  ToLower()  | 현재 문자열의 모든 대문자를 소문자로 바꾼 새 문자열을 반환한다. |
  |  ToUpper()  | 현재 문자열의 모든 소문자를 대문자로 바꾼 새 문자열을 반환한다. |
  |  Insert()   | 현재 문자열의 지정된 위치에 지정된 문자열이 삽입된 새 문자열을 반환한다. |
  |  Remove()   | 현재 문자열의 지정된 위치로부터 지정된 수만큼의 문자가 삭제된 새 문자열을 반환한다. |
  |   Trim()    | 현재 문자열의 앞/뒤에 있는 공백을 삭제한 새 문자열을 반환한다. |
  | TrimStart() | 현재 문자열의 앞에 있는 공백을 삭제한 새 문자열을 반환한다.  |
  |  TrimEnd()  | 현재 문자열의 뒤에 있는 공백을 삭제한 새 문자열을 반환한다.  |

  

##### 3.9.3 문자열 분할하기

- string 혀식은 콤마로 구분된 문자열에서 콤마를 제외한 내용은 단번에 배열로 만들 수 있음. 이것을 가능하게 하는 것은 split() 메소드

- |   메소드    |                             설명                             |
  | :---------: | :----------------------------------------------------------: |
  |   Split()   | 지정된 문자를 기준으로 현재 문자열을 분리한 다음 분리한 문자열의 배열을 반환한다. |
  | SubString() | 현재 문자열의 지정된 위치로부터 지정된 수만큼의 문자로 이루어진 새 문자열을 반환한다. |



##### 3.9.4 문자열 서식 맞추기

- Format() 메소드
  - 서식 항목 추가 옵션 입력
    - {첨자, 맞춤:서식 문자열}
    - `Console.WriteLine("Total : {0, -7: D}", 123); // 첨자:0, 맞춤:-7, 서식 문자열:D`

- 왼쪽/오른쪽 맞춤

  - ```
    string result = string.Format("{0}DEF", "ABC");
    // result : "ABCDEF"
    ```

  - ```
    string result = string.Format("{0, -10}DEF", "ABC");
    // result : "ABC          DEF"
    ```

  - ```
    string result = string.Format("{0, 10}DEF", "ABC");
    // result : "          ABCDEF"
    ```

- 숫자 서식화

  - 수를 서식화하는 기능 지원

  - {첨자, 맞춤: 서식 문자열}

  - | 서식 지정자 |        대상 서식         |                             설명                             |
    | :---------: | :----------------------: | :----------------------------------------------------------: |
    |      D      |          10진수          | 입력된 수를 10진수로 서식화합니다.<br /> `WriteLine("{0:D}", 255); // 255`<br />`WriteLine("{0:D}", 0xFF); // 255` |
    |      X      |          16진수          | 입력된 수를 16진수로 서식화합니다.<br />`WriteLine("{0:X}", 255); // 0xFF`<br />`WriteLine("0:X", 0xFF); // 0xFF` |
    |      N      | 콤마(,)로 묶어 표현한 수 | 입력된 수를 콤마로 구분하여 출력합니다.<br />`WriteLine("{0:N}", 123456789); // 123,456,789.00` |
    |      F      |        고정소수점        | 입력된 수를 고정소수점 형식으로 서식화합니다.<br />`WriteLine("고정소수점: {0:F}", 123.45); // 123.45` |
    |      E      |           지수           | 입력된 수를 지수 표기로 서식화합니다.<br />`WriteLine("공학: {0:E}", 123.456789); // 1.234568E+002` |

- 날씨 및 시간 서식화

  - DateTime 클래스가 필요

    - ```
      DateTime dt = new DateTime(2018, 11, 3, 23, 18, 22); // 2018년 11월 3일 23시 18분 22초
      WriteLine("{0}", dt); // 국가 및 지역 설정에 따라 다른 결과 출력
      ```

  - | 서식 지정자 | 대상 서식 |                             설명                             |
    | :---------: | :-------: | :----------------------------------------------------------: |
    |      y      |   연도    | yy  : 두 자릿수 연도(2018-11-03 23:18:22 ➝ 18)<br />yyyy : 네 자릿수 연도(2018-11-03 23:18:22 ➝ 2018) |
    |      M      |    월     | M : 한 자릿수 월(2018-01-08 21:03:07 ➝ 1)<br />MM : 두 자릿 수 월(2018-01-08 21:03:07 ➝ 01) |
    |      d      |    일     | d : 한 자릿수 일(2018-01-08 21:03:07 ➝ 8)<br />dd : 두 자릿수 일(2018-01-08 21:03:07 ➝ 08) |
    |      h      | 시(1~12)  | h : 한 자릿수 시(2018-01-08 21:03:07 ➝ 9)<br />hh : 두 자릿수 시(2018-01-08 21:03:07 ➝ 09) |
    |      H      | 시(1~23)  | H : 한 자릿수 시(2018-01-08 21:03:07 ➝ 21)<br />HH : 두 자릿수 시(2018-01-08 21:03:07 ➝ 21) |
    |      m      |    분     | m : 한 자릿수 분(2018-01-08 21:03:07 ➝ 3)<br />mm : 두 자릿수 분(2018-01-08 21:03:07 ➝ 03) |
    |      s      |    초     | s : 한 자릿수 초(2018-01-08 21:03:07 ➝ 7)<br />ss : 두 자릿수 초(2018-01-08 21:03:07 ➝ 07) |
    |     tt      | 오전/오후 | tt : 오전/오후(2018-01-08 11:03:07 ➝ 오전,<br />2018-01-08 21:03:07 ➝ 오후) |
    |     ddd     |   요일    | ddd : 약식 요일(2018-11-03 23:18:22 ➝ 토)<br />dddd : 전체 요일(2018-11-03 23:18:22 ➝ 토요일) |

  - ```
    DateTime dt = new DateTime(2018, 11, 3, 23, 18, 22);
    
    // 12시간 형식 : 2018-11-03 오후 11:18:22 (토)
    WriteLine("12시간 형식: {0:yyyy-MM-dd tt hh:mm:ss (ddd)}", dt);
    
    // 24시간 형식 : 2018-11-03 23:18:22 (토요일)
    WriteLine("24시간 형식: {0:yyyy-MM-dd HH:mm:ss (dddd)}", dt);
    ```

  - ```
    CultureInfo ciKo = new CultureInfo("ko-KR");
    
    // 2018-11-03 오후 11:18:22 (토)
    WriteLine(dt.ToString("yyyy-MM-dd hh:mm:ss {ddd}", ciKo));
    
    CultureInfo ciEn = new CultureInfo("en-US");
    
    // 2018-11-03 PM 11:18:22 (Sat)
    WriteLine(dt.ToString("yyyy-MM-dd tt hh:mm:ss (ddd)", ciEn));
    ```

- 문자열 보간

  - `$"텍스트{<보간식>[,길이][:서식]}텍스트{...}..."`

    - 보통 인스턴스의 이름을 지정하지만, 출력할 객체를 반환하는 식을 지정할 수도 있음
    - 길이 옵션, 서식 항목의 [맞춤]과 같음
    - 서식 항목의 [서식 문자열]과 같음

  - |                       string.Format()                        |                         문자열 보간                          |
    | :----------------------------------------------------------: | :----------------------------------------------------------: |
    |             WriteLine("{0},{1}",123,"최강한화");             |              WriteLine($"{123},{"최강한화"}");               |
    |                 WriteLine("{0,-10,D5}",123);                 |                 WriteLine($"{123,-10,:D5}");                 |
    | int n = 123;<br />string s = "최강한화";<br />WriteLine("{0}, {1}, n, s"); | int n = 123;<br />string s = "최강한화";<br />WriteLine($"{n},{s}"); |
    |   int n = 123;<br />WriteLine("{0}", n>100?"큼":"작음",s);   |    int n = 123;<br />WriteLine($"{(n>100?"큼":"작음")}");    |



#### Exer

2. ```
   int a = 7.3;
   float b = 3.14f;
   double c = a * b;
   char d = 'a';
   string e = "한";
   ```

3. 값 형식 : 변수가 값을 담는 데이터 형식

   참조 형식 : 변수가 값 대신 값이 있는 곳의 위치(참조)를 담는 데이터 형식

4. 박싱 : object 형식이 값 형식의 데이터를 힙에 할당하기 위해 제공하는 과정

   언박싱 : 박싱된 값을 꺼내 값 형식 변수에 저장하는 과정

5. `var a = 2020;` - int

   `var b = "double";` - string



### 4장. 데이터를 가공하는 연산자

- 이 장의 핵심 개념
  - 연산자가 무엇인지 이해합니다.
  - 연산자의 종류를 파악하고 사용 방법을 익힙니다.
  - 연산자 사이의 우선순위를 이해합니다.



#### 4.1 C#에서 제공하는 연산자 둘러보기

- |        분류        |                    연산자                    |
  | :----------------: | :------------------------------------------: |
  |    산술 연산자     |                +, -, *, /, %                 |
  |  증가/감소 연산자  |                    ++, --                    |
  |    관계 연산자     |             <, >, ==, !=, <=, >=             |
  |    조건 연산자     |                      ?:                      |
  | null 조건부 연산자 |                   ?., ?[]                    |
  |    논리 연산자     |                 &&, \|\|, !                  |
  |    비트 연산자     |              <<, >>, &,\|, ^, ~              |
  |    할당 연산자     | =, +=, -=, *=, /=, %=, &=, \|=, ^=, <<=, >>= |
  |  null 병합 연산자  |                      ??                      |



#### 4.2 산술 연산자

- 수치 형식(정수, 부동 소수점,  decimal 형식)의 데이터를 다루는 연산자

- | 연산자 |                             설명                             |       지원 형식       |
  | :----: | :----------------------------------------------------------: | :-------------------: |
  |   +    |                  양쪽 피연산자를 더합니다.                   | 모든 수치 데이터 형식 |
  |   -    |       왼쪽 피연산자에서 오른쪽 피연산자를 차감합니다.        | 모든 수치 데이터 형식 |
  |   *    |                  양쪽 피연산자를 곱합니다.                   | 모든 수치 데이터 형식 |
  |   /    |     왼쪽 연산자를 오른쪽 피연산자로 나눈 몫을 구합니다.      | 모든 수치 데이터 형식 |
  |   %    | 왼쪽 연산자를 오른쪽 피연산자로 나눈 후의 나머지를 구합니다. | 모든 수치 데이터 형식 |

- 연산자의 우선순위

  - 수학에서의 사칙연산 우선순위
  - *, /, %가 먼저 처리되고 +, - 가 나중에 처리 됨



#### 4.3 증가 연산자와 감소 연산자

- | 연산자 |    이름     |              설명               |             지원 형식             |
  | :----: | :---------: | :-----------------------------: | :-------------------------------: |
  |   ++   | 증가 연산자 | 피연산자의 값을 1 증가시킵니다. | 모든 수치 데이터 형식과 열거 형식 |
  |   --   | 감소 연산자 | 피연산자의 값을 1 감소시킵니다. | 모든 수치 데이터 형식과 열거 형식 |

- 증가/감소 연산자를 변수 뒤에 사용하면 해당 문장의 실행이 끝난 후에 변수의 값이 변경되지만, 변수 앞에 사용하면 변수의 값을 변경한 후에 해당 문장이 실행됨.

  - ```
    int a = 10;
    Console.WriteLine(a++); // 11이 아닌, 10을 출력, 출력 후에 a는 11로 증가
    Console.WriteLine(++a); // 12를 출력
    ```



#### 4.4 문자열 결합 연산자

- ```
  string result = "123" + "456"; // 123456
  ```



#### 4.5 관계 연산자

- 두 피연산자 사이의 관계를 평가하는 연산자

- ```
  bool result;
  result = 3 > 4; // 거짓
  result = 3 >= 4; // 거짓
  result = 3 < 4; // 참
  result  = 3 <= 4; // 참
  result = 3 == 4; // 거짓
  result = 3 != 4; // 참
  ```



#### 4.6 논리 연산자

- 부울 연산이라고도 하는 논리 연산은 참과 거짓으로 이루어지는 진릿값이 피연산자인 연산

- 논리곱 연산은 피연산자로 오는 두 개의 진릿값이 모두 참이어야 결과가 참이 되고 그 외에는 모두 거짓이 됨

- |  A   |  B   | A && B |
  | :--: | :--: | :----: |
  |  참  |  참  |   참   |
  |  참  | 거짓 |  거짓  |
  | 거짓 | 거짓 |  거짓  |
  | 거짓 |  참  |  거짓  |

- |  A   |  B   | A \|\| B |
  | :--: | :--: | :------: |
  |  참  |  참  |    참    |
  |  참  | 거짓 |    참    |
  | 거짓 | 거짓 |   거짓   |
  | 거짓 |  참  |    참    |

- ```
  int a = 3;
  int b = 4;
  bool c = a < b && b < 5; // c는 true
  bool d = a > b && b < 5; // d는 false (a>b가 거짓이므로)
  bool e = a > b || b < 5; // e는 true (b<5가 참이므로)
  bool f = !e; // f는 false (참인 ture를 부정했으므로)
  ```



#### 4.7 조건 연산자

- 조건 연산자는 특이하게도 피연산자가 세 개나 됨
- `조건식? 참일 때의 값 : 거짓일 때의 값`

- 조건 연산자의 첫 번째 매개변수인 조건식은 결과가 참 또는 거짓의 논리값이어야 함

- 조건의 결과가 참이면 두 번째 매개변수가 선택되고, 거짓이면 세 변째 매개변수가 선택됨

- ```
  int a = 30;
  stirng result = a == 30? "삼십":"삼십아님"; // result는 "삼십"
  ```



#### 4.8 null 조건부 연산자

- == 연산자를 이용한 코드

  - ```
    class Foo
    {
    	public int member;
    }
    
    Foo foo = null;
    
    int? bar;
    if (foo == null)
    	bar = null;
    else
    	bar = foo.member;
    ```

- ?.연산자를 이용한 코드

  - ```
    class Foo
    {
    	public int member;
    }
    
    Foo foo = null;
    
    int? bar;
    bar = foo?.member; // foo 객체가 null이 아니면 memver 필드에 접근하게 해줌
    ```

- ?.와 ?[]는 동일한 기능을 수행하는 연산자지만 객체의 멤버 접근이 아닌 배열과 같은 컬렉션 객체의 첨자를 이용한 참조에 사용된다는 점이 다름.



#### 4.9 비트 연산자

- | 연산자 |           이름            |                             설명                             |                          지원 형식                           |
  | :----: | :-----------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
  |   <<   |    왼쪽 시프트 연산자     | 첫 번째 피연산자의 비트를 두 번째 피연산자의 수만큼 왼쪽으로 이동시킵니다. | 첫 번재 피연산자는 int, uint, long, ulong이며 두 번째 피연산자는 int 형식만 지원힙니다. |
  |   ??   |   오른쪽 시프트 연산자    | 첫 번째 피연산자의 비트를 두 번쨰 피연산자의 수만큼 오른쪽으로 이동시킵니다. |                        <<와 같습니다.                        |
  |   &    |    논리곱(AND) 연산자     |           두 피연산자의 비트 논리곱을 수행합니다.            |    정수 계열 형식과 bool 형식에 대해 사용할 수 있습니다.     |
  |   \|   |     논리합(OR) 연산자     |           두 피연산자의 비트 논리합을 수행합니다.            |                        &와 같습니다.                         |
  |   ^    | 배타적 논리합(XOR) 연산자 |        두 피연산자의 비트 배타적 논리합을 수행합니다.        |                        &와 같습니다.                         |
  |   ~    |     보수(NOT) 연산자      | 피연산자의 비트를 0은 1로, 1은 0으로 반전시킵니다. 단항 연산자입니다. |       int, uint, long, ulong에 대해 사용이 가능합니다.       |



##### 4.9.1 시프트 연산자

- 시프트 연산자는 비트를 왼쪽이나 오른쪽으로 이동시키는 연산자



##### 4.9.2 비트 논리 연산자

- 비트 논리 연산은 비트 덩어리를 이루고 있는 각 비트에 대해 1은 참, 0은 거짓으로 해서 논리 연산을 하는 것

- ```
  int result = 9 & 10; // result는 8
  ```

- ```
  int result = 9 | 10; // result는 11
  ```

- ```
  int a = 255;
  int result = ~a; // result는 -256
  ```



#### 4.10 할당 연산자

- 할당 연산자는 이름처럼 변수 또는 상수에 피연산자 데이터를 할당하는 기능



#### 4.11 null 병합 연산자

- null 병합 연산자??는 null 조건부 연산자처럼 프로그램에서 종종 필요한 변수/객체의 null 검사를 간결하게 만들어주는 역살

- ?? 연산자는 두 개의 피연산자를 받아들이고 왼쪽 피연산자가 null인지 평가

- 평가 결과가 null이 아닌 것으로 나타나면 왼쪽 피연산자를 그대로 반환하고, 왼쪽 피연산자가 null인 것으로 평가되면 오른쪽 피연산자를 반환

- ```
  int? a = null;
  Console.WriteLine("${a ?? 0}"); // a가 null이므로 0이 출력됩니다.
  
  a = 99;
  Console.WriteLine($"{a ?? 0}"); // a는 null이 아니므로 99가 출력됩니다.
  ```



#### 4.12 연산자의 우선순위

| 우선순위 |                  종류                  |               연산자               |
| :------: | :------------------------------------: | :--------------------------------: |
|    1     | 증가/감소 연산자 및 null 조건부 연산자 |      후위++/--연산자, ?., ?[]      |
|    2     |            증가/감소 연산자            |         전위 ++/-- 연산자          |
|    3     |              산술 연산자               |               * / %                |
|    4     |              산술 연산자               |                + =                 |
|    5     |             시프트 연산자              |               <<, >>               |
|    6     |              관계 연산자               |             < > <= >=              |
|    7     |              관계 연산자               |               == !=                |
|    8     |            비트 논리 연산자            |                 &                  |
|    9     |            비트 논리 연산자            |                 ^                  |
|    10    |            비트 논리 연산자            |                 \|                 |
|    11    |              논리 연산자               |                 &&                 |
|    12    |              논리 연산자               |                \|\|                |
|    13    |            null 병합 연산자            |                 ??                 |
|    14    |              조건 연산자               |                 ?;                 |
|    15    |              할당 연산자               | = *= /= %= += -= <<= ??= &= ^= \|= |



#### Exer

1. 증가 연산자를 변수 뒤에 사용하면 해당 문장의 실행이 끝난 후에 변수의 값이 변경되지만, 변수 앞에 사용하면 변수의 값을 변경한 후에 해당 문장이 실행.

   - [참고](#4-3-증가-연산자와-감소-연산자)

2. ```
   i = i + 1; // 2
   i++; // 1
   ++i; // 2
   i += 1; // 2
   ```

3. ```
   int a = 8 >> 1; // 4
   int b = a >> 2; // 1
   ```

4. ```
   int a = 0xF0 | 0x0F; // 255
   ```

5. ```
   int a = 10;
   string b = a == 0 ? "가나다" : "ABC"; // ABC
   ```



### 5장. 코드의 흐름 제어하기

- 이 장의 핵심 개념
  - 프로그래밍에서 흐름 제어의 역할을 이해합니다.
  - 분기문을 이해하고 사용 방법을 익힙니다.
  - 반복문을 이해하고 사용 방법을 익힙니다.
  - 점프문을 이해하고 사용 방법을 익힙니다.



#### 5.1 분기문

- 분기문은 프로그램의 흐름을 조건에 따라 여러 갈래로 나누는 흐름 제어 구문입니다.
- C#에서는 한 번에 단 하나의 조건만 평가할 수 있는 if문과 한 번에 여러 개의 조건을 평가할 수 있는 switch 문, 이렇게 두 가지의 분기문을 제공합니다.



##### 5.1.1 if, else 그리고 else if

- if 문에서 사용하는 조건식은 true 또는 false의 값을 가지는 bool 형식이어야 함.

- ```
  if (조건식)
  	{
  		참인_경우에_실행할_코드;
  	}
  ```

- ```
  int a = 10;
  if ((a % 2) == 0)
  	Console.WriteLine("짝수");
  ```

- ```
  if ((a % 2) == 0)
  	Console.WriteLine("짝수");
  else
  	Console.WriteLine("홀수");
  ```

- ```
  int a = -10;
  
  if (a < 0)
  	Console.WriteLine("음수");
  else if (a > 0)
  	Console.WriteLine("양수");
  else
  	Console.WriteLine("0");
  	
  ```



##### 5.1.2 if문 중첩해서 사용하기

- ```
  if (number > 0)
  {
  	if (number % 2 == 0)
  		Console.WriteLine("0보다 큰 짝수");
  	else
      	Console.WriteLine("0보다 큰 홀수");
  }
  else
  {
  	Console.WriteLine("0보다 작거나 같은 수");
  }
  ```



##### 5.1.3 switch 문

- switch 문은 조건식의 결과가 가질 수 있는 다양한 경우를 한번에 평가하고 프로그램을 가를 때 사용

- ```
  switch (조건식)
  {
  	case 상수1:
  		// 실행할 코드
  		break;
  	case 상수2:
  		// 실행할 코드
  		break;
  	case 상수N:
  		// 실행할 코드
  		break;
  	default:
  		// 실행할 코드
  		breal;
  }
  ```

- 부동소수형 값의 일치 여부 판단용으로 switch 문을 사용하는 일은 자제. 반올림 오차로 인해 의도한 결과와 다르게 동작할 수 있기에

- break : 프로그램의 흐름을 멈추고 현재 실행 중인 코드의 바깥으로 실행 위치를 옮기는 역할

- ```
  int number = 1;
  switch (number)
  {
  	case 1:
  		Console.WriteLine("하나");
  		break;
  	case 2:
  		Console.WriteLine("둘");
  		break;
  	case 3:
  		Console.WriteLine("셋");
  		break;
  	default:
  		Console.WriteLine("제가 아는 숫자는 1, 2, 3 뿐입니다.");
  		break;		
  	
  }
  ```

- ```
  object obj = 123; // C# 컴파일러는 123 리터럴을 평가하여 int 형식임을 유추합니다. 그리고 obj 안에 박싱해 넣습니다.
  
  switch(obj)
  {
  	case int i: // obj에 담겨 있는 데이터의 형식이 int 이므로 프로그램은 이 case 절을 따라 분기합니다.
  		...
  		break;
  	case float f:
  		...
  		break;
  	default:
  		...
  		break;
  }
  ```

- TryParse() vs Parse()

  - 두 메소드는 문자열을 숫자로 변환하는 같은 기능을 함.
  - Parse() 메소드는 변환이 실패하면 예외를 던짐
  - TryParse() 메소드는 변환의 성공여부를 반환하기 때문에 현재의 코드 흐름을 유지할 수 있음
  - TryParse()가 변환한 데이터는 두 번째 매개변수에 저장됨. 이 매개변수는 특이하게 out이라는 키워드로 수식되어 있는데 out키워드는 출력 전용 매개변수임을 나타내는 요도로 쓰임 

- 데이터 형식에 따라 분기하는 경우, switch 문의 when절을 이용하여 추가적인 조건 검사를 수행할 수 있음

  - ```
    switch (obj)
    {
    	case int i:
    		Console.WriteLine($"{i}는 int 형식입니다.");
    		break;
    	case float f when f >= 0: // obj가 float 형식이며 0보다 크거나 같을 경우
    		Console.WriteLine($"{f}는 양의 float 형식입니다.");
    		break;
    	case float f:
    		Console.WriteLine($"{f}는 음의 float 형식입니다.");
    		break;
    	default:
    		Console.WriteLine($"{obj}은(는) 모르는 형식입니다.");
    		break;		
    }
    ```



##### 5.1.4 switch 식

- 식은 어떤 계산을 해서 결과를 내놓고 문은 어떤 일을 하는 것

- ```
  int input = Convert.ToInt32(Console.ReadLine());
  
  // 1의 자리를 버림. ex) 92 -> 90. 87 -> 80
  int score = (int)(Math.Truncate(input/10.0) * 10);
  string grade = "";
  
  switch(score)
  {
  	case 90:
  		grade = "A";
  		break;
  	case 80:
  		grade = "B";
  		break;
  	case 70:
  		grade = "C";
  		break;
  	case 60:
  		grade = "D";
  		break;
  	default:
  		grade = "F";
  		break;
  }
  ```

- ```
  int input = Convert.ToInt32(Console.ReadLine());
  
  // 1의 자리를 버림. ex) 92 -> 90. 87 -> 80
  int score = (int)(Math.Truncate(input/10.0) * 10);
  string grade = score switch
  {
  	90 => "A",
  	80 => "B",
      70 => "C",
      60 => "D",
      _ => "F"
  }
  ```

- ```
  bool reapeated = true;
  
  string grade = score switch
  {
  	90 when reapeated == true => "B+", // score가 90이어도 repeated가 true이면 "B+" 
  	90 => "A",
  	80 => "B",
      70 => "C",
      60 => "D",
      _ => "F"
  }
  ```



#### 5.2 반복문

- 특정 조건을 만족하는 동안 코드 또는 코드 블록을 반복해서 실행하도록 하는 문장
  - while
  - do while
  - for
  - for each



##### 5.2.1 while

- ```
  while (조건식)
  	반복실행할_코드
  ```

- while 키워드 옆의 조건식은 if문에서의 조건식과 마찬가지로 논리 형식

- while 문은 조건식이 참인 동안 코드를 반복 실행

- 조건식이 false 값을 갖지 못한다면 프로그램은 while 문에서 영원히 헤어나오지 못하는데 이걸 무한반복이라함.

##### 5.2.2 do while

- while 문과 유사한 반복문이지만, while문이 조건식을 평가한 후 그 결과가 참이면 코드를 실행하는 데 반해, do while 문은 조건식을 평가하기 전에 무조건 처음 한 번은 코드를 실행함

- ```
  do
  {
  	반복실행할_코드_블록 // 이 코드블록은 최초 한번은 무조건 실행됩니다.
  }
  while(조건식); // do while 문과 while문의 또 다른 차이점은 ;
  ```



#### 5.2.3 for

- ```
  for(초기화식; 조건식; 반복식;)
  	반복실행할_코드;
  ```

- for문 구성하는 요소

  - 초기화식 : 반복을 실행하기 전에 가장 먼저, 딱 한번만 실행되는 코드. for 반복문에서 사용할 변수 등을 이곳에서 초기화합니다.
  - 조건식 : 반복을 계속 수행할지를 결정하는 식. 조건식의 결과가 false가 되면 반복을 중단.
  - 반복식 : 반복이 끝낼때마다 실행. 주로 여기서 조건식에서 사용하는 변수의 값을 조정. 반복식이 실행된 후에는 조건식이 실행되어 반복을 계속 진행할지 판단.

- ```
  for (int i=0; i < 5; i++)
  	ConsoleWriteLine(i);
  ```



#### 5.2.4 중첩 for

- ```
  for (int i=0; i<5; i++)
  	for (int j=0; j<10; j++)
  ```



##### 5.2.5 foreach

- ```
  foreach(데이터형식 변수명 in 배열_또는_컬렉션)
  	코드_또는_코드블록
  ```

- foreach문은 in 키워드와 함께 사용하는데 foreach문이 한 번 반복을 수행할 때마다 배열 또는 컬렉션의 요소를 차례때로 순회하면서 in 키워드 앞에 있는 변수에 담아줌.

  - ```
    int[] arr = new int[]{0, 1, 2, 3, 4}; // 배열은 이렇게 선언
    
    for each (int a in arr)
    {
    	Console.WriteLine(a);
    }
    ```



##### 5.2.6 for 또는 while을 이용한 무한 반복 코드

- ```
  for(;;)
  	// 반복 실행할 코드 블록
  ```

- ```
  while(true)
  	// 반복 실행할 코드 블록
  ```



#### 5.3 점프문

- 점프문은 흐름을 끊고 프로그램의 실행 위치를 원하는 곳으로 단숨에 도약시킬 수 있음
  - break
  - continue
  - goto
  - return
  - throw



##### 5.3.1 break

- 현재 실행 중인 반복문이나 switch 문의 실행을 중단하고자 할 때 사용
- 프로그램의 실행 위치는 while 블록 다음으로 옮겨짐



##### 5.3.2 continue

- 한 회 건너 뛰어 반복을 계속 수행하게 하는 기능



##### 5.3.3 goto

- ```
  goto 레이블;
  
  레이블: // 레이블을 선언할 때는 콜론(:)을 붙입니다.
  	// 이어지는 코드
  ```

- 레이블은 코드 안의 위치를 나타내는 표지판 같은 존재. goto문은 레이블이 가리키는 곳으로 바로 뛰어넘어감



### 6장. 메소드로 코드 간추리기

- 이 장의 핵심 개념
  - 메소드가 무엇인지, 어떤 구조로 만들어지는지 이해합니다.
  - 메소드의 결과가 반환하는 return 문을 이해합니다.
  - 매개변수의 역할과 기능을 이해합니다.
  - 메소드에게 매개변수를 전달하는 여러 가지 방법을 이해합니다.
  - 메소드 오버로딩을 이해합니다.
  - 알아두면 편리한 매개변수 옵션의 사용법을 익힙니다.



#### 6.1 메소드란?

- 메소드는 일련의 코드를 하나의 이름 아래 묶은 것

- ```
  class 클래스_이름
  {
  	한정자 반환_형식 메소드_이름(매개변수_목록)
  	{
  		// 실행하고자 하는 코드 1
  		// 실행하고자 하는 코드 2
  		// ...
  		// 실행하고자 하는 코드 n
  		
  		return 메소드_결과;
  	}
  }
  ```

  - 메소드의 속성을 수식하는 한정자를 둘 수 있습니다.
  - 매개변수_목록 : 메소드에 입력하는 매개변수의 목록입니다.

- 클래스 안에 선언되는 메소드는 매개변수와 반환형식을 가짐

- ```
  class Calculator
  {
  	public static int Plus(int a, int b)
  	{
  		Console.WriteLine("Input : {0}, {1}", a, b);
          
          int result = a + b;
          return result;
  	}
  }
  ```

- 이렇게 선언한 메소드는 다음과 같이 사용 가능

  - ```
    int x = Calculator.Plus(3, 4); // x는 7
    ```

- 매개변수는 메소드가 호출자에게서 전달받은 값을 받는 변수

- 인수는 호출자가 매개변수에 넘기는 값

- void 반환 형식

  - 모든 메소드들이 결과를 반환하는 것은 아니고 어떤 메소드들은 자기 할 일만 하고 종료하기도 함.
    - ex. Write(), WriteLine()
    - 이런 메소드를 선언할 때는 반환 형식에 void 넣어주면 됨.

- static 한정자

  - C#에서 static은 메소드나 필드가 클래스의 인스턴스가 아닌 클래스 자체에 소속되도록 지정하는 한정자



#### 6.2 return에 대하여

- return 문은 점프문의 한 종류로 프로그램의 흐름을 갑자기 호출자에게 돌려놓음
- 재귀 호출 - 메소드가 자기 자신을 스스로 호출하는 것을 일컬어 부름



#### 6.3 매개변수에 대하여

- 메소드를 호출할 때 데이터를 복사해서 매개변수에 넘기는 것 : 값에 의한 전달



#### 6.4 참조에 의한 매개변수 전달

- 매개변수를 "참조에 의한 전달"로 넘기면 값에 의한 전달이 매개변수가 변수나 상수로부터 값을 복사하는 것과 달리 매개변수가 메소드에 넘겨진 원본 변수를 직접 참조

- 메소드 안에서 매개변수를 수정하면 매개변수가 참조하고 있는 원본 변수에 수정이 이루어짐.

- ```
  static void Swap(ref int a, ref int b)
  {
  	int temp = b;
  	b = a;
  	a = temp;
  }
  ```



#### 6.5 메소드의 결과를 참조로 반환하기

- 메소드의 결과를 참조로 반환하는 참조 반환값

- 참조반환값을 이용하면 메소드의 호출자로 하여금 반환받은 결과를 참조로 다룰 수 있도록 함.

- ref 한정자를 이용해서 메소드를 선언하고, return 문이 반환하는 변수 앞에도 ref키워드를 명시해야 함.

- ```
  class SomeClass
  {
  	int SomeValue = 10;
  	
  	public ref int SomeMethod()  // ref 키워드로 메소드를 한정합니다.
  	{
  		// 이런 일 저런 일
  		return ref SomeValue;  // return 문을 사용할 떄 ref 키워드를 반환할 필드나 객체 앞에 붙여줍니다.
  	}
  }
  ```

- SomeMethod()는 참조로 반환하도록 구현됐지만, 호출자가 특별한 키워드를 사용하지 않는 한 값으로 반환하는 평범한 메소드처럼 동작

  - ```
    SomeClass obj = new SomeClass();
    int result = obj.SomeMethod(); // 값으로 반환하고자 할 떄는 여느 때와 다름없이 메소드를 호출하면 됩니다.
    ```

- 참조로 반환받은 결과를 담는 지역 변수를 참조 지역 변수라 부름

  - ````
    SomeClass obj = new SomeClass();
    ref int result = ref obj.SomeMethod(); // result는 참조 지역 변수입니다.
    ````



#### 6.6 출력 전용 매개변수

- ref 키워드를 이용해서 메소드를 구현하면 몫과 나머지를 한 번에 반환할 수 있음

  - ```
    void Divide(int a, int b, ref int quotient, ref int remainder)
    {
    	quotient = a/ b;
    	remainder = a % b;
    }
    ```

- out 키워드를 이용한 출력 전용 매개변수

  - 메소드의 선언부와 호출부에 ref 키워드 대신 out 키워드를 사용하면 됨

  - ```
    void Divide( int a, int b, out int uotient, out int remainder)
    {
    	quotient = a / b;
    	remainder = a % b;
    }
    ```

  - ```
    int a = 20;
    int b = 3;
    int c;
    int d;
    
    Divide(a, b, out c, out d);
    
    Console.WriteLine("Quotient:{0}, Remainder {1}", c, d);
    ```

- ref 키워드를 이용해서 매개변수를 넘기는 경우 메소드가 해당 매개변수에 결과를 저장하지 않아도 컴파일러는 아무런 경고를 하지 않음

- out 키워드를 이용해서 매개변수를 넘길 때는 메소드가 해당 매개변수에 결과를 저장하지 않으면 컴파일러가 에러 메시지를 출력

- 컴파일러가 호출당하는 메소드에서 그 지역 변수를 할당할 것을 보장하기 때문에 메소드를 호출하는 쪽에서는 초기화하지 않은 지역 변수를 메소드의 out 매개변수로 넘길 수 있음

- 런타임에 발생하는 버그는 컴파일 타임에 발생하는 버그보다 훨씬 잡기가 어렵기 때문에 컴파일러를 통해 결과를 할당하지 않는 버그가 만들어질 가능성을 제거할 수 있다면 그 방법을 사용해야 함.

- 출력 전용 매개변수는 메소드를 호출하기 전에 미리 선언할 필요가 없음. 호출할 때 매개변수 목록 안에서 즉석으로 선언하면 됨

  - ```
    int a = 20;
    int b = 3;
    // int c;
    // int d;
    
    Divide(a, b, out c, out d);
    
    Console.WriteLine("Quotient:{0}, Remainder {1}", c, d);
    ```



#### 6.7 메소드 오버로딩

- 메소드 오버로딩 : 하나의 메소드 이름에 여러 개의 구현을 올리는 것

  - ```
    int Plus(int a, int b)
    {
    	return a + b;
    }
    
    double Plus(double a, double b)
    {
    	return a + b;
    }
    ```

  - ```
    int result1 = Plus(1, 2); // int Plus(int, int)를 호출합니다.
    double result2 = Plus(3.1, 2.4); // double Plus(double, double)를 호출합니다.
    ```

- 메소드 오버로딩은 이름에 대한 고민을 줄여주는 동시에 코드를 일관성있게 유지해줌.



#### 6.8 가변 개수의 인수

- 가변 개수의 인수란 그 개수가 유연하게 변할 수있는 인수

- 가변 개수의 인수는 params 키워드와 배열을 이용해서 선언

- ```
  int Sum(params int[] args)
  {
  	int sum = 0;
  	for(int i=0; i<args.Length; i++)
  	{
  		sum += args[i];
  	}
  	
  	return sum;
  }
  ```



#### 6.9 명명된 인수

- 명명된 인수 : 메소드를 호출할 때 인수의 이름에 근거해서 데이터를 할당할 수 있는 기능
- 메소드를 호출할 때만 인수의 이름 뒤에 콜론(:)을 붙인 뒤 그 뒤에 할당할 데이터를 넣어주면 됨.



#### 6.10 선택적 인수

- 메소드의 매개변수는 기본값을 가질 수 있음

- 매개변수를 특정 값으로 초기화하듯 메소드를 선언할 수 있음

- ```
  void MyMethod(int a, int b = 0)
  {
  	Console.WriteLine("{0},{1}",a,b);
  }
  ```

- 기본값을 가진 매개변수는 필요에 따라 인수를 할당하거나 할당하지 않을 수 있기 때문에 선택적 인수라고 부름

- 선택적 인수는 항상 필수 인수 뒤에 와야 함.



#### 6.11 로컬 함수

- 로컬함수는 메소드 안에서 선언되고, 선언된 메소드 안에서만 사용되는 특별한 함수

- 로컬함수는 자신이 존재하는 지역에 선언되어 있는 변수를 사용할 수 있음

- ```
  class SomeClass
  {
  	public void SomeMethod() // 메소드 선언
  	{
  		int count = 0;
          SomeLocalFunction(1, 2); // 로컬 함수 호출
          SomeLocalFunction(3, 4);
          
          void SomeLocalFunction(int a, int b) // 로컬 함수 선언
          {
          	// Do Some Work
          	Console.WriteLine($"count : {++count}"); // 로컬 함수는 자신이 속한 메소드의 지역 변수를 사용할 수 있습니다.
          
          }
  	}
  
  }
  ```



### 7장. 클래스

- 이 장의 핵심 개념
  - 객체지향 프로그래밍과 클래스의 정의를 이해합니다.
  - 클래스를 선언하고 객체를 생성하는 방법을 익힙니다.
  - 인스턴스 멤버와 정적 멤버의 차이를 이해합니다.
  - 객체를 복사하는 방법과 주의해야 할 점을 익힙니다.
  - 클래스 클래스 멤버를 보호하는 접근 한정자의 종류롸 역할을 이해합니다.
  - 클래스 간의 상속을 이해합니다.
  - 메소드 오버라이딩과 다형성을 이해합니다.



#### 7.1 객체지향 프로그래밍과 클래스

- 객체지향 프로그래밍(OOP)
  - 코드내의 모든 것을 객체로 표현하고자 하는 프로그래밍 패러다임
  - 속성 - 데이터
  - 기능 - 메소드
- 클래스
  - 객체를 만들기 위한 청사진
  - 객체가 가지게 될 속성과 기능을 정의하지만 실체를 가지지 않음
- 객체에서 뽑아낸 속성과 기능은 클래스 안에 변수와 메소드로 표현됨.



#### 7.2 클래스 선언과 객체의 생성

- ```
  class 클래스이름
  {
  	// 데이터와 메소드
  }
  ```

- ```
  class Cat
  {
  	public string Name;
  	public string Color;
  	
  	public void Meow() // 메소드
  	{
  		Console.WriteLine("{0} : 야옹", Name);
  	}
  }
  ```

  - Cat 클래스에 선언된 Name과 Color처럼 클래스 안에 선언된 변수들을 일컬어 필드라고 함.
  - 필드와 메소드를 비롯하여 프로퍼티, 이벤트 등 클래스 내에 선언된 요소들을 일컬어 멤버라고 함.

- ```
  Cat kitty = new Cat();
  ```

  - Cat()은 생성자라고 하는 특별한 메소드
  - 생성자는 클래스의 이름과 동일한 이름을 가지며, 객체를 생성하는 역할을 함.
  - Cat() 생성자 앞에 있는 new 키워드는 생성자를 호출해서 객체를 생성하는 데 사용하는 연산자

- new 연산자와 생성자는 모든 데이터 형식에 사용할 수 있음.



#### 7.3 객체의 삶과 죽음에 대하여: 생성자와 종료자

- 객체가 생성될 때는 생성자가 호출되고 소멸할 때는 종료자가 호출

##### 7.3.1 생성자

- 클래스를 선언할 때 명시적으로 생성자를 구현하지 않아도 컴파일러에서 생성자를 만들어줌.

- 컴파일러가 자동으로 만들어줘도 객체를 다루다 보면 객체를 생성하는 시점에 객체의 상태를, 다시 말해 객체의 필드를 원하는 값으로 초기화하고 싶을 때가 있기에 생성자를 구현해야 함.

- 매개변수를 입력받아 원하는 값으로 필드를 초기화할 수 있는 최적의 장소가 생성자

- ```
  class Cat
  {
  	public Cat() // public : 한정자, Cat() : 생성자
  	{
  		Name = "";
  		Color = "";
  	}
  	
  	public Cat(string _Name, string _Color) // 객체를 생성할 떄 이름과 색을 입력ㅂ다아 초기화함.
  	{
  		Name = _Name;
          Color = _Color;
  	}
  	
  	public string Name;
  	public string Color;
  }
  ```

  - 매개변수가 없는 버전의 Cat()생성자는 컴파일러가 자동으로 생성해준 생성자를 호출할 때처럼 사용하면 되고, 매개변수가 있는 버전의 Cat() 생성자는 생성자의 괄호 안에 필요한 인수를 입력하면 됨.

##### 7.3.2 종료자

- 종료자의 이름은 클래스 이름 앞에 ~를 붙인 꼴

- 생성자와는 달리 매개변수도 없고, 한정자도 사용하지 않음

- 여러 버전의 종료자를 만드는 오버로딩도 불가능하며 직접 호출할 수도 없음.

- CLR의 가비지 컬렉터가 객체가 소멸되는 시점을 판단해서 종료자를 호출

- ```
  class 클래스이름
  {
  	~클래스이름() // 종료자
  	{
  		//
  	}
  	// 필드
  	// 메소드
  }
  ```

- 가급적 사용하지 않는 것이 좋음

  - CLR의 가비지 컬렉터가 언제 동작할 지 예측할 수 없음
  - 종료자를 명시적으로 구현하면 가비지 컬렉터는 클래스의 족보를 타고 올라가 객체로부터 상속받은 Finalize()메소드를 호출함. 이렇게 하면 응용 프로그램의 성능 저하를 초래할 확률이 높아 권장하지 않음.
  - CLR의 가비지 컬렉터는 우리보다 훨씬 더 똑똑하게 객체의 소멸을 처리할 수 있기에 생성은 생성자에, 뒷처리는 가비지 컬렉터에 맡기는 편이 좋음.



#### 7.4 정적 필드와 메소드

- C#에서 static은 메소드나 필드가 클래스의 인스턴스가 아닌 클래스 자체에 소속되도록 지정하는 한정자
- static으로 수식한 필드는 프로그램 전체에 걸쳐 하나밖에 존재하지 않음.
- 프로그램 전체에 걸쳐 공유해야 하는 변수가 있다면 정적 필드를 이용하면 됨
- 정적 메소드 역시 정적 필드처럼 인스턴스가 아닌 클래스 자체에 소속됨.
- 정적 메소드는 클래스의 인스턴스를 생성하지 않아도 호출이 가능한 메소드
- 인스턴스 메소드 : 클래스의 인스턴스를 생성해야만 호출할 수 있는 메소드
- 보통 객체 내부의 데이터를 이용해야 하는 경우에는 인스턴스 메소드를 선언하고, 내부 데이터를 이용할 일이 없는 경우에는 별도의 인스턴스 생성없이 호출할 수 있도록 메소드를 정적으로 선언



#### 7.5 객체 복사하기: 얕은 복사와 깊은 복사

- 객체를 복사할 때 참조만 살짝 복사하는 것을 얕은 복사

- target이 힙에 보관되어 있는 내용을 source로부터 복사해서 받아 별도의 힙 공간에 객체를 보관하는 것이 깊은 복사

- ```
  class MyClass
  {
  	public int MyField1;
  	public int MyField2;
  	public MyClass DeepCopy()
  	{
  		MyClass newCopy = new MyClass();
  		newCopy.MyField1 = this.MyField1;
  		newCopy.MyField2 = this.MyField2;
  		return newCopy;
  	}
  }
  ```

- ICloneable.Clone() 메소드 -Clone() 메소드 하나만 갖고 있으며 객체를 힙에 새로 할당해서 그곳에 자신의 멤버를 일일이 복사해 넣음.



#### 7.6 this 키워드

##### 7.6.1 나

-  this는 객체가 자신을 지칭할 때 사용하는 키워드. 객체 내부에서 자신의 필드와 메소드에 접근할 때 this 키워드 사용.

##### 7.6.2 this() 생성자

- this()는 자기자신의 생성자를 가리킴.
- this()는 생성자에서만 사용될 수 있음.
- 생성자의 코드블록 내부가 아닌 앞쪽에서만 사용 가능



#### 7.7 접근 한정자로 공개 수준 결정하기

- 객체 지향 프로그래밍의 3대 특성

  - 은닉성, 상속성,다형성

- 접근 한정자 - 감추고 싶은 것은 감추고 보여주고 싶은 것은 보여줄 수 있도록 코드를 수식하며 필드, 메소드를 비롯해 프로퍼티 드 ㅇ모든 요소에 사용할 수 있음

- | 접근 한정자        | 설명                                                         |
  | ------------------ | ------------------------------------------------------------ |
  | public             | 클래스의 내부/외부 모든 곳에서 접근할 수 있습니다.           |
  | protected          | 클래스의 외부에서는 접근할 수 없지만, 파생 클래스에서는 접근이 가능합니다. |
  | private            | 클래스의 내부에서만 접근할 수 있습니다. 파생 클래스에서도 접근이 불가능합니다. |
  | internal           | 같은 어셈블리에 있는 코드에서만 public으로 접근할 수 있습니다.다른 어셈블리에 있는 코드에서는 private과 같은 수준의 접근성을 가집니다. |
  | protected internal | 같은 어셈블리에 있는 코드에서만 protected로 접근할 수 있습니다. 다른 어셈블리에 있는 코드에서는 private과 같은 수준의 접근성을 가집니다. |
  | private protected  | 같은 어셈블리에 있는 클래스에서 상속받은 클래스 내부에서만 접근이 가능합니다. |

- 접근 한정자로 수식하지 않은 클래스의 멤버는 무조건 private으로 접근 수준이 자동 지정.

  - 클래스 내의 멤버는 일단 감추고 나중에 공개할지를 결정하는 것이 순서
